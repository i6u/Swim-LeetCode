## 题目描述


给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

示例 1:

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2

示例 2:

输入: nums =  [3,3,7,7,10,11,11]
输出: 10

提示:

1 <= nums.length <= 105
0 <= nums[i] <= 105

典型的二分题，关键之处在于敏锐捕获题目中有用信息，找到如何二分。

leetcode地址：[原题地址](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/solution/niu-niu-ma-te-er-fen-fa-de-ling-huo-yun-vecsq/)

## 问题分析

先想一种最简单的方法，快速进入节奏：通过查看相邻点，遍历一遍一定可以得到结果。但这样复杂度是O(n)，不满足要求。
既然是有序数组，又要求 O(log n)，那这题八九不离十是要用二分法。我们知道，如果找某个数字，我们可以在有序数组通过二分左右选择，但是本题是找那个特殊的单身数字，所以不能直接划分，一定有什么规律，让我们可以进行左右抉择。
​

## 二分法


我们注意到，题目有说每个元素都会出现两次，唯有一个数只会出现一次。我们先想想如果全部数字都是成对出现，那么就是偶数位置、奇数位置相同数字成对出现，但由于引入了一个单独的数字，所以从这个数字开始，后面的规律就反过来了，也就是说，我们可以基于这个规则分左右。



具体来说，二分到某个位置，找到最近的偶数位置，如果这个偶数位置的值，和它下一个位置的值相等，说明特殊位置还未出现，我们向右搜索。反之，这个偶数位置的值，和它下一个位置的值不相等了，说明特殊数字已出现，我们向左边搜索。这样直到左右相等，就是特殊数字的位置。

时间复杂度O(n)
空间复杂度O(1)​


实现代码如下（更多语言可查看github）：

``` golang
func singleNonDuplicate(nums []int) int {
	left, right := 0, len(nums)-1
	for left < right {
		mid := left + (right-left) / 2
		// 数据是成对的，我们每次mid取偶数位置
		if mid % 2 == 1 {
			mid = mid - 1
		}
		// 满足特殊数字出现前规律，向右寻找
		if nums[mid] == nums[mid+1] {
			// 加2是由于数字成对出现
			left = mid + 2
		} else {
			// 如果规律改变，就向左寻找
			right = mid
		}
	}
	return nums[left]
}
```

## 最后
如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~

所有题解已经加入 [Swim-LeetCode](https://github.com/niuniumart/Swim-LeetCode) 项目，欢迎 star 哦 ~